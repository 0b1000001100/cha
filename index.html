<!DOCTYPE html>
<html lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
  <title>文字種変換</title>
  <style>
    body{display:flex;gap:16px;padding:24px;flex-wrap:wrap}
    .col{flex:1;flex-basis:300px;display:flex;flex-direction:column;gap:8px}
    textarea{width:100%;height:300px;padding:12px;font-size:16px;resize:vertical;box-sizing: border-box}
    pre{white-space:pre-wrap;word-break:break-word;background:#f4f4f4;padding:12px;border-radius:6px;max-width: 100%;box-sizing:border-box}
    .row{display:flex;gap:8px}
    button{padding:8px 12px;border-radius:6px;border:1px solid #ccc;background:#fff}
  </style>
</head>
<body>
  <div class="col">
    <label for="input">入力</label>
    <textarea id="input" placeholder="ここに文字を入力"></textarea>
    <div class="row">
      <button id="clearInput">入力クリア</button>
      <button id="shareOutput">出力を共有</button>
      <button id="copyOutput">出力コピー</button>
    </div>
  </div>
  <div class="col">
    <label for="output">変換結果</label>
    <pre id="output" aria-live="polite"></pre>
  </div>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
  <script>
    const input = document.getElementById('input');
    const output = document.getElementById('output');
    const clearBtn = document.getElementById('clearInput');
    const copyBtn = document.getElementById('copyOutput');
    const shareBtn = document.getElementById('shareOutput');

    let isComposing = false;

    const smallHiragana = new Set(['ぁ','ぃ','ぅ','ぇ','ぉ','ゃ','ゅ','ょ','ゎ','ゕ','ゖ','っ']);
    const smallKatakana = new Set(['ァ','ィ','ゥ','ェ','ォ','ャ','ュ','ョ','ヮ','ヵ','ヶ','ッ']);

    function mapChar(ch){
      // 伸ばし棒はそのまま
      if (ch === 'ー') return ch;

			// アルファベット＋ダイアクリティカル対応
  		// NFDで分解（例: é → e + ́）
			const nfd = ch.normalize("NFD");
			const base = nfd[0];
			const marks = nfd.slice(1);

			// ストローク付きなど独立文字のマッピングは先に判定
			const strokeMap = {
				"Ⱥ": "Ⱥ", 
				"ⱥ": "ⱥ", 
				"Ƀ": "Ⱥ", 
				"ƀ": "ⱥ", 
				"Ȼ": "Ⱥ", 
				"ȼ": "ⱥ", 
				"Đ": "Ⱥ", 
				"đ": "ⱥ", 
				"Ð": "Ⱥ", 
				"ð": "ⱥ", 
				"Ɖ": "Ⱥ", 
				"ɖ": "ⱥ", 
				"Ɇ": "Ⱥ", 
				"ɇ": "ⱥ", 
				"Ǥ": "Ⱥ", 
				"ǥ": "ⱥ", 
				"Ħ": "Ⱥ", 
				"ħ": "ⱥ", 
				"Ɨ": "Ⱥ", 
				"ɨ": "ⱥ", 
				"Ɉ": "Ⱥ", 
				"ɉ": "ⱥ", 
				"Ł": "Ⱥ", 
				"ł": "ⱥ", 
				"Ƚ": "Ⱥ", 
				"ƚ": "ⱥ", 
				"Ø": "Ⱥ", 
				"ø": "ⱥ", 
				"Ɵ": "Ⱥ", 
				"ɵ": "ⱥ", 
				"Ᵽ": "Ⱥ", 
				"ᵽ": "ⱥ", 
				"Ɍ": "Ⱥ", 
				"ɍ": "ⱥ", 
				"Ŧ": "Ⱥ", 
				"ŧ": "ⱥ", 
				"Ⱦ": "Ⱥ", 
				"ⱦ": "ⱥ", 
				"Ʉ": "Ⱥ", 
				"ʉ": "ⱥ", 
				"Ɏ": "Ⱥ", 
				"ɏ": "ⱥ", 
				"Ƶ": "Ⱥ", 
				"ƶ": "ⱥ"
			};
			if (strokeMap[ch]) return strokeMap[ch];

			if (/[A-Z]/.test(base)) {
				return "A" + marks;
			}
			if (/[a-z]/.test(base)) {
				return "a" + marks;
			}
      
      const code = ch.codePointAt(0);
      if ((code >= 0x3040 && code <= 0x309F)){
        if (smallHiragana.has(ch)) return 'ぁ';
        return 'あ';
      }
      if ((code >= 0x30A0 && code <= 0x30FF)){
        if (smallKatakana.has(ch)) return 'ァ';
        return 'ア';
      }
      if ((code >= 0x4E00 && code <= 0x9FFF) || (code >= 0x3400 && code <= 0x4DBF)){
        return '漢';
      }
      if (ch >= '0' && ch <= '9') return '1';
      if (ch >= 'A' && ch <= 'Z') return 'A';
      if (ch >= 'a' && ch <= 'z') return 'a';
      if (
      	(code >= 0x1100 && code <= 0x11FF) || // Jamo
  			(code >= 0x3130 && code <= 0x318F) || // 互換Jamo
  			(code >= 0xAC00 && code <= 0xD7AF)    // 音節
			) {
 				 return '가';
			}
      return ch;
    }

    function transformText(text){
      let out = '';
      for (const ch of text) out += mapChar(ch);
      return out;
    }

    input.addEventListener('compositionstart', ()=> isComposing = true);
    input.addEventListener('compositionend', ()=>{ isComposing = false; handleInput(); });

    function handleInput(){
      if (isComposing) return;
      const start = input.selectionStart;
      const end = input.selectionEnd;
      const original = input.value;
      const transformed = transformText(original);
      output.textContent = transformed;
      // keep cursor positions logically same
      try{
        input.setSelectionRange(start, end);
      }catch(e){/* ignore */}
    }

    input.addEventListener('input', handleInput);

    clearBtn.addEventListener('click', ()=>{ input.value=''; output.textContent=''; input.focus(); });

    copyBtn.addEventListener('click', async ()=>{
      try{ 
        await navigator.clipboard.writeText(output.textContent);
        Toastify({
          text: "コピーしました",
          duration: 1000,
          close: true,
          gravity: "bottom",
          position: "center",
          style: {
            background: "#0a0a0a",
            boxShadow: "0 0 10px #000"
          },
          oldestFirst: false
        }).showToast();
      }
      catch{
        Toastify({
          text: "コピーに失敗しました",
          duration: 1000,
          close: true,
          gravity: "bottom",
          position: "center",
          style: {
            background: "#0a0a0a",
            boxShadow: "0 0 10px #000"
          },
          oldestFirst: false
        }).showToast();
      }
    });

    shareBtn.addEventListener('click', async ()=>{
      try{
        await navigator.share({ text: output.textContent });
      }
      catch{
        Toastify({
          text: "共有に失敗しました",
          duration: 1000,
          close: true,
          gravity: "bottom",
          position: "center",
          style: {
            background: "#0a0a0a",
            boxShadow: "0 0 10px #000"
          },
          oldestFirst: false
        }).showToast();
      }
    });

    // initial
    handleInput();
  </script>
</body>
</html>
